### 전역 상태 관리 라이브러리 - Redux

**전역 상태 관리가 왜 필요한가**

React.js는 기본적으로 **단방향 데이터 흐름**(one-way data flow)을 가진다. 즉, **부모 컴포넌트에서 자식 컴포넌트 방향**으로 props를 통해 데이터를 전달하는 것이 일반적이라는 의미이다.(물론, setState 함수를 자식 컴포넌트에 props로 전달하여 state 값을 부모로 끌어올리는 것도 가능) 이러한 특징은 서비스의 구조를 직관적으로 만들어주었지만, **몇 가지 비효율** 또한 발생시킨다.

1. 상태 공유와 데이터 동기화    
대규모 애플리케이션에서 `여러 컴포넌트가 동일한 데이터를 공유해야 할 때` 전역 상태 관리는 유용하다. 전역 상태를 통해 컴포넌트 간에 데이터를 공유하고 동기화할 수 있으므로, 데이터의 일관성을 유지할 수 있다.

2. 컴포넌트 간 데이터 전달 단순화   
전역 상태 관리를 사용하면 데이터를 `한 컴포넌트에서 다른 컴포넌트로 전달하는 작업을 간소화`할 수 있다. 데이터를 상태로 저장하고 필요한 컴포넌트에서 상태를 읽어오는 방식으로 데이터 흐름을 관리하므로, 컴포넌트 트리 구조가 복잡한 경우에도 데이터 전달이 용이해진다.

3. 상태 업데이트 예측 가능성   
전역 상태 관리를 사용하면 `애플리케이션의 상태 업데이트를 중앙에서 관리할 수 있다.` 이는 예측 가능한 상태 업데이트를 제공하고, 여러 컴포넌트에서 일관된 방식으로 상태를 업데이트할 수 있다. 이를 통해 버그를 줄이고 개발자 경험을 향상시킨다.

4. 로컬 상태와 전역 상태의 분리    
전역 상태 관리를 사용하면 `컴포넌트의 로컬 상태와 전역 상태를 명확하게 분리`할 수 있습니다. 컴포넌트의 로컬 상태는 해당 컴포넌트에만 영향을 미치며, 전역 상태는 여러 컴포넌트 간에 공유될 수 있습니다. 이를 통해 코드의 유지 보수성과 재사용성이 향상됩니다.

5. 개발자 도구와 향상된 디버깅 기능    
전역 상태 관리 라이브러리는 `보통 개발자 도구와 통합되어 개발 프로세스를 지원`한다. 상태 변화를 추적하고 기록하거나, 디버깅 도구를 통해 상태를 쉽게 검사하고 수정할 수 있다. 이는 애플리케이션의 디버깅과 성능 최적화에 도움을 준다.

### 전역 상태 라이브러리
- 복잡한 애플리케이션에서 데이터 상태를 효율적으로 관리하기 위해 사용되는 도구
- 여러 컴포넌트 간에 데이터를 공유하고 상태를 업데이트하는 방식을 제공

|목적|설명|
|---|---|
|중앙 집중화된 상태 관리|전역 상태 관리 라이브러리는 애플리케이션의 상태를 하나의 중앙 위치에 저장하고 관리함. 이를 통해 여러 컴포넌트 간에 데이터를 공유하고 동기화할 수 있음. 각 컴포넌트에서는 필요한 상태를 직접 관리하는 대신, 전역 상태를 읽고 업데이트하는 방식으로 작업할 수 있음.|
|예측 가능한 상태 업데이트|전역 상태 관리 라이브러리는 일관성과 예측 가능성을 제공함. 애플리케이션의 상태 변경은 라이브러리를 통해 관리되며, 엄격한 규칙과 패턴을 따르기 때문에 상태 업데이트가 예측 가능하고 추적 가능함.|
|컴포넌트 간 데이터 공유|전역 상태 관리를 통해 여러 컴포넌트에서 동일한 데이터를 공유할 수 있음. 이를 통해 복잡한 컴포넌트 트리 구조에서 데이터 전달을 간소화하고 컴포넌트 간의 상태 동기화를 용이하게 함.|
|상태 변경의 중앙 관리|전역 상태 관리 라이브러리는 상태 변경에 대한 중앙 관리 기능을 제공함. 이를 통해 상태 업데이트를 추적하고 기록할 수 있으며, 필요한 경우 로깅, 디버깅, 시간 여행 등과 같은 추가 기능을 제공할 수도 있음.|
 
### Redux의 구조
View에서 이벤트가 발생하여 전역 state를 업데이트해주는 상황을 가정해보면...
1. View(컴포넌트)에서는 dispatch를 통해 Action을 발동시킨다. 
```jsx
const dispatch = useDispatch();

dispatch(loginAction({
	email: emailInput, 
	pw: pwInput
});
```
2. Action이 발동되면, Reducer는 현재 상태와 전달받은 액션 객체를 파라미터로 받아온다. Reducer는 state의 불변성을 유지하면서 데이터를 변화시켜야 한다. 따라서 데이터를 변화시킬 때는 spread 연산자를 사용한다. 
```jsx
const mainReducer = (state = initialState, action) => {
	switch (action.type) {
		case 'LOGIN': {
			return {
				...state,
				email: action.data.email,
				pw: action.data.pw
			}
		}
		default: {
			return {...state}
		} 
	}
}
```
3. View(컴포넌트)에서 state를 구독(subscribe)하기 위해서는 
**useSelector**을 사용한다.
```jsx
const { email, pw } = useSelector(state => state.mainReducer);
```
### Redux의 3가지 규칙
- **단일 스토어** : 전역 상태를 관리하는 스토어를 1개만 두자! 
(여러 개의 스토어를 사용하는 것이 불가능하지는 않지만, 권장되지 않음.)
- **읽기 전용(read-only) state** : 리덕스 state는 읽기 전용이므로, 기존의 객체를 건드리지 않고 **새로운 객체를 생성하여 업데이트** 해주는 방식을 사용하자!
- **Reducer는 순수한 함수**여야 함 : Reducer는 이전 상태와 액션 객체를 파라미터로 받는다. 이전의 상태는 절대 건드리지 않고, 변화를 일으킨 새로운 state 객체를 만들어서 반환(return)한다. 따라서, **똑같은 파라미터(INPUT)로 호출된 Reducer 함수**는 **언제나 똑같은 결과값**(OUTPUT)을 반환해야한다.